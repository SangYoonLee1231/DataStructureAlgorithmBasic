# 선택 정렬 (Selection Sort)

# 시간 복잡도 = N + (N-1) + ... + 1 = O(N^2)



# 버블 정렬 (Bubble Sort)

# 시간 복잡도 = N + (N-1) + .. + 1 = O(N^2)



# 퀵 소트 (Quick Sort)

# T(N) = 2T(N/2) + N
# = 2(2T(N/4)+ N/2) + N = 4T(N/4) + N + N
# = 4T(N/4) + 2N
# = 8T(N/8) + 3N
# = ...
# = 2^kT(N/2^k) + kN ( k -> ∞ , 2^k ≒ N )
# = NT(1) + (logN / log2) * N ( T(1) = 0 )
# = N * (logN / log2)

# 시간 복잡도 = O(N * (logN / log2))

# < 면접 단골질문 >
# 사실상 최악의 경우 (수열이 내림차순으로 정렬되어 있는 경우) 시간복잡도가 O(N^2)이나,
# pivot(기준점)을 랜덤으로 잡거나 중앙으로 잡거나 하는 방식으로 최적화를 한다면
# 시간 복잡도를 O(N * (logN / log2))으로 생각해도 무방하다.
# unstable (사건 복잡도가 불안정하다)



# 병합 정렬 (Merge Sort)

# 2 pointer 이용

# T(N) = 2T(N/2) + N 
# 시간 복잡도 = O(kN) ( 1 * 2^k = N )
# = O(N * (logN / log2))
# stable (사건 복잡도가 안정적이다)
# 메모리 할당을 많이 쓴다 (합칠 떄 새로운 배열을 이미 만들어 놔야 하므로)



# Radix Sort

# 메모리가 넘쳐날 때, 수의 범위를 알 때(짧을 때) 쓰임
# 수의 개수를 세서 배열에 저장, 반복문 통해 작은 수부터 나열